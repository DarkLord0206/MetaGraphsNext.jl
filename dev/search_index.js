var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Basics","page":"API reference","title":"Basics","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MetaGraphsNext]\nPages = [\"metagraph.jl\"]","category":"page"},{"location":"api/#MetaGraphsNext.MetaGraph","page":"API reference","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph{T,Label,Graph,VertexMeta,EdgeMeta,GraphMeta,WeightFunction,U} <: AbstractGraph{T}\n\nA graph type with custom vertex labels containing vertex-, edge- and graph-level metadata.\n\nVertex labels have type Label, while vertex (resp. edge, resp. graph) metadata has type VertexMeta (resp. EdgeMeta, resp. GraphMeta). It is recommended not to set Label to Int to avoid confusion between vertex labels and vertex codes (which have type T <: Integer).\n\nFields\n\ng::Graph: underlying, data-less graph with vertex indices of type T\nvprops::Dict{Label,Tuple{T,VertexMeta}}: dictionary mapping vertex labels to vertex codes and metadata\neprops::Dict{Tuple{Label,Label},EdgeMeta}: dictionary mapping edge labels such as (label_u, label_v) to edge metadata\ngprops::GraphMeta: graph metadata\nweightfunction::WeightFunction: function defining edge weight from edge metadata\ndefaultweight::U: default weight for the edges\nmetaindex::Dict{T,Label}: dictionary mapping vertex codes to vertex labels\n\n\n\n\n\n","category":"type"},{"location":"api/#MetaGraphsNext.MetaGraph-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}, Tuple{Vertex}} where {Vertex, T}","page":"API reference","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph(g;\n    Label = Symbol,\n    VertexMeta = nothing,\n    EdgeMeta = nothing,\n    gprops = nothing,\n    weightfunction = eprops -> 1.0,\n    defaultweight = 1.0\n)\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MetaGraphsNext]\nPages = [\"metaundigraph.jl\", \"metadigraph.jl\"]","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MetaGraphsNext]\nPages = [\"dict_utils.jl\"]","category":"page"},{"location":"api/#Base.haskey-Tuple{MetaGraph, Any, Any}","page":"API reference","title":"Base.haskey","text":"haskey(g, :v1, :v2)\n\nDetermine whether a graph g contains an edge from :v1 to :v2. The order of :v1 and :v2 only matters if g is a digraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{MetaGraph, Any}","page":"API reference","title":"Base.haskey","text":"haskey(g, :label)\n\nDetermine whether a graph g contains the vertex :label.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.code_for-Tuple{MetaGraph, Any}","page":"API reference","title":"MetaGraphsNext.code_for","text":"code_for(meta::MetaGraph, vertex_label)\n\nFind the code associated with a vertex_label. This can be useful to pass to methods inherited from Graphs. Note, however, that vertex codes could be reassigned after vertex deletion.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.label_for-Tuple{MetaGraph, Any}","page":"API reference","title":"MetaGraphsNext.label_for","text":"label_for(meta::MetaGraph, vertex_code)\n\nFind the label associated with a vertex_code. This can be useful to interpret the results of methods inherited from Graphs. Note, however, that vertex codes could be reassigned after vertex deletion.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MetaGraphsNext]\nPages = [\"weights.jl\"]","category":"page"},{"location":"api/#MetaGraphsNext.defaultweight-Tuple{MetaGraph}","page":"API reference","title":"MetaGraphsNext.defaultweight","text":"defaultweight(g)\n\nReturn the default weight for metagraph g.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.weightfunction-Tuple{MetaGraph}","page":"API reference","title":"MetaGraphsNext.weightfunction","text":"weightfunction(g)\n\nReturn the weight function for metagraph g.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.weighttype-Union{Tuple{MetaGraph{var\"#s11\", var\"#s12\", var\"#s13\", var\"#s14\", var\"#s15\", var\"#s16\", var\"#s17\", Weight} where {var\"#s11\", var\"#s12\", var\"#s13\", var\"#s14\", var\"#s15\", var\"#s16\", var\"#s17\"}}, Tuple{Weight}} where Weight","page":"API reference","title":"MetaGraphsNext.weighttype","text":"weighttype(g)\n\nReturn the weight type for metagraph g.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.jl-interface","page":"API reference","title":"Graphs.jl interface","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MetaGraphsNext]\nPages = [\"graphs.jl\"]","category":"page"},{"location":"api/#Graphs.SimpleGraphs.add_edge!-Tuple{MetaGraph, Integer, Integer, Any}","page":"API reference","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(g, u, v, val)\n\nAdd an edge (u, v) to MetaGraph g having value val.\n\nReturn true if the edge has been added, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.add_vertex!-Tuple{MetaGraph, Any, Any}","page":"API reference","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(g, label, val)\n\nAdd a vertex to MetaGraph g with label label having value val.\n\nReturn true if the vertex has been added, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MetaGraphsNext]\nPages = [\"overrides.jl\"]","category":"page"},{"location":"api/#Reading-/-writing","page":"API reference","title":"Reading / writing","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MetaGraphsNext]\nPages = [\"persistence.jl\"]","category":"page"},{"location":"api/#MetaGraphsNext.DOTFormat","page":"API reference","title":"MetaGraphsNext.DOTFormat","text":"struct DOTFormat <: AbstractGraphFormat end\n\nIf all metadata types support pairs or are nothing, you can save MetaGraphs in DOTFormat.\n\n\n\n\n\n","category":"type"},{"location":"api/#MetaGraphsNext.MGFormat","page":"API reference","title":"MetaGraphsNext.MGFormat","text":"struct MGFormat <: AbstractGraphFormat end\n\nYou can save MetaGraphs in a MGFormat, currently based on JLD2.\n\n\n\n\n\n","category":"type"},{"location":"tutorial_files/#Read-/-write","page":"Reading / writing","title":"Read / write","text":"","category":"section"},{"location":"tutorial_files/","page":"Reading / writing","title":"Reading / writing","text":"julia> using Graphs\n\njulia> using MetaGraphsNext","category":"page"},{"location":"tutorial_files/#DOTFormat","page":"Reading / writing","title":"DOTFormat","text":"","category":"section"},{"location":"tutorial_files/","page":"Reading / writing","title":"Reading / writing","text":"julia> simple = MetaGraph(Graph());\n\njulia> simple[:a] = nothing; simple[:b] = nothing; simple[:a, :b] = nothing;\n\njulia> mktemp() do file, io\n            savegraph(file, simple, DOTFormat())\n            print(read(file, String))\n        end\ngraph T {\n    a\n    b\n    a -- b\n}\n\njulia> complicated = MetaGraph(DiGraph(),\n            VertexMeta = Dict{Symbol, Int},\n            EdgeMeta = Dict{Symbol, Int},\n            gprops = (tagged = true,)\n        );\n\njulia> complicated[:a] = Dict(:code_1 => 1, :code_2 => 2);\n\njulia> complicated[:b] = Dict(:code => 2);\n\njulia> complicated[:a, :b] = Dict(:code => 12);\n\njulia> mktemp() do file, io\n            savegraph(file, complicated, DOTFormat())\n            print(read(file, String))\n        end\ndigraph G {\n    tagged = true\n    a [code_1 = 1, code_2 = 2]\n    b [code = 2]\n    a -> b [code = 12]\n}","category":"page"},{"location":"tutorial_files/#MGFormat","page":"Reading / writing","title":"MGFormat","text":"","category":"section"},{"location":"tutorial_files/","page":"Reading / writing","title":"Reading / writing","text":"julia> example = MetaGraph(Graph());\n\njulia> mktemp() do file, io\n            savegraph(file, example)\n            loadgraph(file, \"something\", MGFormat()) == example\n        end\ntrue","category":"page"},{"location":"tutorial_basics/#Working-with-metagraphs","page":"Basics","title":"Working with metagraphs","text":"","category":"section"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"julia> using Graphs\n\njulia> using MetaGraphsNext","category":"page"},{"location":"tutorial_basics/#Creating-a-MetaGraph","page":"Basics","title":"Creating a MetaGraph","text":"","category":"section"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"We provide a default constructor in which you only need to specify types:","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"julia> colors = MetaGraph(Graph(), VertexMeta = String, EdgeMeta = Symbol, gprops = \"special\")\nMeta graph based on a {0, 0} undirected simple Int64 graph with vertices indexed by Symbol(s), String(s) vertex metadata, Symbol(s) edge metadata, \"special\" as graph metadata, and default weight 1.0","category":"page"},{"location":"tutorial_basics/#Adding-and-modifying-vertices","page":"Basics","title":"Adding and modifying vertices","text":"","category":"section"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"Use setindex! (as you would do with a dictionary) to add a new vertex with the given metadata. If a vertex with the given label does not exist, it will be created automatically. Otherwise, setindex! will modify the metadata for the existing vertex.","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"julia> colors[:red] = \"warm\";\n\njulia> colors[:yellow] = \"warm\";\n\njulia> colors[:blue] = \"cool\";","category":"page"},{"location":"tutorial_basics/#Using-vertex-codes","page":"Basics","title":"Using vertex codes","text":"","category":"section"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"In the absence of removal, vertex codes correspond to order of insertion in the underlying graph:","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"julia> code_for(colors, :red)\n1\n\njulia> code_for(colors, :blue)\n3","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"You can retrieve the associated labels as follows:","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"julia> label_for(colors, 1)\n:red\n\njulia> label_for(colors, 3)\n:blue","category":"page"},{"location":"tutorial_basics/#Accessing-metadata","page":"Basics","title":"Accessing metadata","text":"","category":"section"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"You can access and change the metadata using indexing: zero arguments for graph metadata, one label for vertex metadata, and two labels for edge metadata.","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"julia> colors[]\n\"special\"\n\njulia> colors[:blue] = \"very cool\";\n\njulia> colors[:blue]\n\"very cool\"\n\njulia> colors[:red, :yellow] = :orange;\n\njulia> colors[:red, :yellow]\n:orange","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"Checking the presence of a vertex or edge can be done with haskey:","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"julia> haskey(colors, :red)\ntrue\n\njulia> haskey(colors, :green)\nfalse\n\njulia> haskey(colors, :red, :yellow)\ntrue\n\njulia> haskey(colors, :yellow, :red) # undirected graph, so vertex order doesn't matter\ntrue\n\njulia> haskey(colors, :red, :green)\nfalse","category":"page"},{"location":"tutorial_basics/#Deleting-vertices-and-edges","page":"Basics","title":"Deleting vertices and edges","text":"","category":"section"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"You can delete vertices and edges with delete!.","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"julia> delete!(colors, :red, :yellow);\n\njulia> delete!(colors, :blue);","category":"page"},{"location":"tutorial_basics/#Adding-weights","page":"Basics","title":"Adding weights","text":"","category":"section"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"The most simple way to add edge weights is to speficy a default weight for all of them.","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"julia> defaultweight(MetaGraph(Graph(), defaultweight = 2))\n2\n\njulia> weighttype(MetaGraph(Graph(), defaultweight = 2))\nInt64","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"You can use the weightfunction keyword to specify a function which will transform edge metadata into a weight. This weight must always be the same type as the defaultweight.","category":"page"},{"location":"tutorial_basics/","page":"Basics","title":"Basics","text":"julia> weighted = MetaGraph(Graph(), EdgeMeta = Float64, weightfunction = identity);\n\njulia> weighted[:red] = nothing; weighted[:blue] = nothing; weighted[:yellow] = nothing;\n\njulia> weighted[:red, :blue] = 1.0; weighted[:blue, :yellow] = 2.0;\n\njulia> the_weights = Graphs.weights(weighted)\nmetaweights\n\njulia> size(the_weights)\n(3, 3)\n\njulia> the_weights[1, 3]\n1.0\n\njulia> diameter(weighted)\n3.0\n\njulia> weightfunction(weighted)(0)\n0","category":"page"},{"location":"tutorial_graphs/#Graphs.jl-interface","page":"Graphs.jl interface","title":"Graphs.jl  interface","text":"","category":"section"},{"location":"tutorial_graphs/","page":"Graphs.jl interface","title":"Graphs.jl interface","text":"julia> using Graphs\n\njulia> using MetaGraphsNext","category":"page"},{"location":"tutorial_graphs/","page":"Graphs.jl interface","title":"Graphs.jl interface","text":"MetaGraphs inherit many methods from Graphs.jl. In general, inherited methods refer to vertices by codes, not labels, for compatibility with AbstractGraph. Vertex codes get reassigned after rem_vertex! to remain contiguous, so we recommend using labels if possible.","category":"page"},{"location":"tutorial_graphs/#Undirected-graphs","page":"Graphs.jl interface","title":"Undirected graphs","text":"","category":"section"},{"location":"tutorial_graphs/","page":"Graphs.jl interface","title":"Graphs.jl interface","text":"julia> colors = MetaGraph(Graph(), VertexMeta = String, EdgeMeta = Symbol, gprops = \"special\");\n\njulia> colors[:red] = \"warm\";\n\njulia> colors[:yellow] = \"warm\";\n\njulia> is_directed(colors)\nfalse\n\njulia> nv(zero(colors))\n0\n\njulia> ne(copy(colors))\n0\n\njulia> add_vertex!(colors, :white, \"neutral\")\ntrue\n\njulia> add_edge!(colors, 1, 3, :pink)\ntrue\n\njulia> rem_edge!(colors, 1, 3)\ntrue\n\njulia> rem_vertex!(colors, 3)\ntrue\n\njulia> rem_vertex!(colors, 3)\nfalse\n\njulia> eltype(colors) == Int\ntrue\n\njulia> edgetype(colors) == Edge{Int}\ntrue\n\njulia> vertices(colors)\nBase.OneTo(2)\n\njulia> has_edge(colors, 1, 2)\nfalse\n\njulia> has_vertex(colors, 1)\ntrue\n\njulia> Graphs.SimpleGraphs.fadj(colors, 1) == Int[]\ntrue\n\njulia> Graphs.SimpleGraphs.badj(colors, 1) == Int[]\ntrue\n\njulia> colors == colors\ntrue\n\njulia> issubset(colors, colors)\ntrue\n\njulia> SimpleGraph(colors)\n{2, 0} undirected simple Int64 graph","category":"page"},{"location":"tutorial_graphs/#Directed-graphs","page":"Graphs.jl interface","title":"Directed graphs","text":"","category":"section"},{"location":"tutorial_graphs/","page":"Graphs.jl interface","title":"Graphs.jl interface","text":"You can seemlessly make MetaGraphs based on DiGraphs as well.","category":"page"},{"location":"tutorial_graphs/","page":"Graphs.jl interface","title":"Graphs.jl interface","text":"julia> rock_paper_scissors = MetaGraph(DiGraph(), Label = Symbol, EdgeMeta = Symbol);\n\njulia> rock_paper_scissors[:rock] = nothing; rock_paper_scissors[:paper] = nothing; rock_paper_scissors[:scissors] = nothing;\n\njulia> rock_paper_scissors[:rock, :scissors] = :rock_beats_scissors; rock_paper_scissors[:scissors, :paper] = :scissors_beats_paper; rock_paper_scissors[:paper, :rock] = :paper_beats_rock;\n\njulia> is_directed(rock_paper_scissors)\ntrue\n\njulia> haskey(rock_paper_scissors, :scissors, :rock)\nfalse\n\njulia> haskey(reverse(rock_paper_scissors), :scissors, :rock)\ntrue\n\njulia> SimpleDiGraph(rock_paper_scissors)\n{3, 3} directed simple Int64 graph\n\njulia> sub_graph, _ = induced_subgraph(rock_paper_scissors, [1, 3]);\n\njulia> haskey(sub_graph, :rock, :scissors)\ntrue\n\njulia> delete!(rock_paper_scissors, :paper);\n\njulia> rock_paper_scissors[:rock, :scissors]\n:rock_beats_scissors","category":"page"},{"location":"#MetaGraphsNext.jl","page":"Home","title":"MetaGraphsNext.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to MetaGraphsNext.jl, an experimental, type-stable replacement for MetaGraphs.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To see how the package works, take a look at the tutorial. We first explain the basics of the MetaGraph structure, before moving on to its integration with Graphs.jl.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [MetaGraphsNext]","category":"page"}]
}
